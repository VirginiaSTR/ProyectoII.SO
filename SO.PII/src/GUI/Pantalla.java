/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package GUI;

import javax.swing.JOptionPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import Logica.Estructuras.Lista;
import Logica.Clases.Archivo;
import Logica.Clases.TreeNodeData;
import java.awt.Color;
import java.awt.Component;
import java.awt.Point;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.TreeNode;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 *
 * @author VirginiaT
 */

public class Pantalla extends javax.swing.JFrame {

    
    private Lista<Archivo> listaArchivos;
    private DefaultMutableTreeNode raiz;
    private int idSiguiente;
    private String modoSistema;
    private ArrayList<String> listaLogOperaciones = new ArrayList<>();
    
    
    public Pantalla(Lista<Archivo> listaArchivos) {
        initComponents();
        
        raiz = new DefaultMutableTreeNode("Raíz");
        treeDirectorio = new DefaultTreeModel(raiz);
        jTree1.setModel(treeDirectorio);
        this.listaArchivos = listaArchivos;
        idSiguiente = obtenerIdMasGrande() + 1;
        modoSistema = "Usuario";
        llenarTablaArchivos();
        btnCrearArchivo.setVisible(false);
        btnCrearCarpeta.setVisible(false);
        btnEliminar.setVisible(false);
        btnModificarContenido.setVisible(false);
        btnModificarNombre.setVisible(false);
        btnLogBackup.setVisible(false);
        btnImportarArchivos.setVisible(false);     //Estos dos botones eran para pruebas. Cumplieron su cometido.
        btnExportarArchivos.setVisible(false);
        actualizarTabla();
    }
    
    DefaultTreeModel treeDirectorio;
    
    
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        SDtable = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        btnCrearArchivo = new javax.swing.JButton();
        btnCrearCarpeta = new javax.swing.JButton();
        btnEliminar = new javax.swing.JButton();
        btnModificarContenido = new javax.swing.JButton();
        btnModificarNombre = new javax.swing.JButton();
        btnModo = new javax.swing.JButton();
        btnLog = new javax.swing.JButton();
        btnImportarArchivos = new javax.swing.JButton();
        btnExportarArchivos = new javax.swing.JButton();
        btnImportarArbol = new javax.swing.JButton();
        btnExportarArbol = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        tablaAsignacionArchivos = new javax.swing.JTable();
        btnLogBackup = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(153, 153, 255));
        jPanel1.setLayout(null);

        SDtable.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        SDtable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""},
                {"", "", "", "", "", "", "", ""}
            },
            new String [] {
                "", "", "", "", "", "", "", ""
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        SDtable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        SDtable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                SDtableMouseClicked(evt);
            }
        });
        jScrollPane1.setViewportView(SDtable);
        if (SDtable.getColumnModel().getColumnCount() > 0) {
            SDtable.getColumnModel().getColumn(0).setHeaderValue("");
            SDtable.getColumnModel().getColumn(1).setHeaderValue("");
            SDtable.getColumnModel().getColumn(2).setHeaderValue("");
            SDtable.getColumnModel().getColumn(3).setHeaderValue("");
            SDtable.getColumnModel().getColumn(4).setHeaderValue("");
            SDtable.getColumnModel().getColumn(5).setHeaderValue("");
            SDtable.getColumnModel().getColumn(6).setHeaderValue("");
            SDtable.getColumnModel().getColumn(7).setHeaderValue("");
        }

        jPanel1.add(jScrollPane1);
        jScrollPane1.setBounds(20, 370, 560, 140);

        jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 18)); // NOI18N
        jLabel1.setText("Estado del SD");
        jPanel1.add(jLabel1);
        jLabel1.setBounds(30, 330, 130, 21);

        jTree1.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        jTree1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTree1MouseClicked(evt);
            }
        });
        jScrollPane2.setViewportView(jTree1);

        jPanel1.add(jScrollPane2);
        jScrollPane2.setBounds(30, 60, 440, 210);

        btnCrearArchivo.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnCrearArchivo.setText("Crear Archivo");
        btnCrearArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearArchivoActionPerformed(evt);
            }
        });
        jPanel1.add(btnCrearArchivo);
        btnCrearArchivo.setBounds(480, 80, 170, 30);

        btnCrearCarpeta.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnCrearCarpeta.setText("Crear Carpeta");
        btnCrearCarpeta.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearCarpetaActionPerformed(evt);
            }
        });
        jPanel1.add(btnCrearCarpeta);
        btnCrearCarpeta.setBounds(480, 40, 170, 30);

        btnEliminar.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnEliminar.setText("Eliminar");
        btnEliminar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEliminarActionPerformed(evt);
            }
        });
        jPanel1.add(btnEliminar);
        btnEliminar.setBounds(480, 120, 170, 30);

        btnModificarContenido.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnModificarContenido.setText("Modificar Contenido");
        btnModificarContenido.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnModificarContenidoActionPerformed(evt);
            }
        });
        jPanel1.add(btnModificarContenido);
        btnModificarContenido.setBounds(480, 200, 170, 30);

        btnModificarNombre.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnModificarNombre.setText("Modificar Nombre");
        btnModificarNombre.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnModificarNombreActionPerformed(evt);
            }
        });
        jPanel1.add(btnModificarNombre);
        btnModificarNombre.setBounds(480, 160, 170, 30);

        btnModo.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnModo.setText("Modo");
        btnModo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnModoActionPerformed(evt);
            }
        });
        jPanel1.add(btnModo);
        btnModo.setBounds(30, 20, 100, 30);

        btnLog.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnLog.setText("Log de Operaciones");
        btnLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLogActionPerformed(evt);
            }
        });
        jPanel1.add(btnLog);
        btnLog.setBounds(480, 240, 170, 30);

        btnImportarArchivos.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnImportarArchivos.setText("Importar Archivos");
        btnImportarArchivos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnImportarArchivosActionPerformed(evt);
            }
        });
        jPanel1.add(btnImportarArchivos);
        btnImportarArchivos.setBounds(860, 530, 170, 30);

        btnExportarArchivos.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnExportarArchivos.setText("Exportar Archivos");
        btnExportarArchivos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportarArchivosActionPerformed(evt);
            }
        });
        jPanel1.add(btnExportarArchivos);
        btnExportarArchivos.setBounds(680, 530, 170, 30);

        btnImportarArbol.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnImportarArbol.setText("Importar JTree");
        btnImportarArbol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnImportarArbolActionPerformed(evt);
            }
        });
        jPanel1.add(btnImportarArbol);
        btnImportarArbol.setBounds(250, 280, 170, 30);

        btnExportarArbol.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnExportarArbol.setText("Exportar JTree");
        btnExportarArbol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExportarArbolActionPerformed(evt);
            }
        });
        jPanel1.add(btnExportarArbol);
        btnExportarArbol.setBounds(70, 280, 170, 30);

        tablaAsignacionArchivos.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        tablaAsignacionArchivos.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null}
            },
            new String [] {
                "ID", "Nombre", "N° de Bloques", "Ubicación", "Color"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane3.setViewportView(tablaAsignacionArchivos);

        jPanel1.add(jScrollPane3);
        jScrollPane3.setBounds(600, 370, 500, 140);

        btnLogBackup.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        btnLogBackup.setText("Respaldar Log");
        btnLogBackup.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLogBackupActionPerformed(evt);
            }
        });
        jPanel1.add(btnLogBackup);
        btnLogBackup.setBounds(480, 280, 170, 30);

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Recursos Gráficos/Buffer1.PNG"))); // NOI18N
        jPanel1.add(jLabel2);
        jLabel2.setBounds(700, 40, 380, 294);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 1126, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 586, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


public class CeldaColorEspecificoRenderer extends DefaultTableCellRenderer {

    private List<CeldaInfo> celdasColoreadas = new ArrayList<>();

    public void setColorCelda(int fila, int columna, Color color) {
        eliminarCelda(fila, columna);
        celdasColoreadas.add(new CeldaInfo(fila, columna, color));
    }

    private void eliminarCelda(int fila, int columna) {
        for (int i = celdasColoreadas.size() - 1; i >= 0; i--) {
            CeldaInfo celda = celdasColoreadas.get(i);
            if (celda.fila == fila && celda.columna == columna) {
                celdasColoreadas.remove(i);
                break;
            }
        }
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        c.setBackground(table.getBackground()); // Color predeterminado

        boolean celdaColoreada = false;
        for (CeldaInfo celda : celdasColoreadas) {
            if (celda.fila == row && celda.columna == column) {
                c.setBackground(celda.color);
                celdaColoreada = true;
                System.out.println("printprueba " + celda.fila + " " + celda.columna);
                break;
            }
        }

        if (!celdaColoreada) {
            c.setBackground(table.getBackground()); // Asegura el color predeterminado
            ((JLabel) c).setText(""); // Establece el texto a vacío
        }

        return c;
    }

    public static class CeldaInfo {
        public int fila;
        public int columna;
        public Color color;

        public CeldaInfo(int fila, int columna, Color color) {
            this.fila = fila;
            this.columna = columna;
            this.color = color;
        }
    }
}
    
    private CeldaColorEspecificoRenderer renderer = new CeldaColorEspecificoRenderer(); // Instancia del renderizador

    public void cambiarColorCelda(int fila, int columna, Color color) {
        renderer.setColorCelda(fila, columna, color);
        SDtable.getColumnModel().getColumn(columna).setCellRenderer(renderer);
        SDtable.repaint();
    }
    
    
    public static Color obtenerColorPorNombre(String nombreColor) {
    if (nombreColor == null || nombreColor.isEmpty()) {
        return Color.BLACK; // Color por defecto si el nombre es nulo o vacío
    }

    switch (nombreColor.toLowerCase()) {
        case "negro":
            return Color.BLACK;
        case "blanco":
            return Color.WHITE;
        case "rojo":
            return Color.RED;
        case "rojoclaro":
            return new Color(255, 182, 193); // LightPink
        case "rojooscuro":
            return new Color(139, 0, 0); // DarkRed
        case "verde":
            return Color.GREEN;
        case "verdeclaro":
            return new Color(144, 238, 144); // LightGreen
        case "verdeoscuro":
            return new Color(0, 100, 0); // DarkGreen
        case "azul":
            return Color.BLUE;
        case "azulclaro":
            return new Color(173, 216, 230); // LightBlue
        case "azuloscuro":
            return new Color(0, 0, 139); // DarkBlue
        case "amarillo":
            return Color.YELLOW;
        case "amarilloclaro":
            return new Color(255, 255, 224); // LightYellow
        case "amarillooscuro":
            return new Color(255, 215, 0); // Gold
        case "cyan":
            return Color.CYAN;
        case "cyanclaro":
            return new Color(224, 255, 255); // LightCyan
        case "cyanoscuro":
            return new Color(0, 139, 139); // DarkCyan
        case "magenta":
            return Color.MAGENTA;
        case "magentaclaro":
            return new Color(238, 130, 238); // Violet
        case "magentaoscuro":
            return new Color(139, 0, 139); // DarkMagenta
        case "grisoscuro":
            return Color.DARK_GRAY;
        case "gris":
            return Color.GRAY;
        case "grisclaro":
            return Color.LIGHT_GRAY;
        case "naranja":
            return Color.ORANGE;
        case "naranjaclaro":
            return new Color(255, 228, 196); // Bisque
        case "naranjaoscuro":
            return new Color(255, 140, 0); // DarkOrange
        case "rosa":
            return Color.PINK;
        case "rosaoscuro":
            return new Color(219, 112, 147); // MediumVioletRed
        default:
            return Color.BLACK; // Color por defecto si no se encuentra el nombre
    }
}
    
    
    
    private void SDtableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SDtableMouseClicked

        int fila = SDtable.getSelectedRow();
        int columna = SDtable.getSelectedColumn();
        
        System.out.println(" Fila: " + fila + " Columna: " + columna);

        if (fila != -1 && columna != -1) {
            int numeroCelda = fila * SDtable.getColumnCount() + columna;
            String valorActual = (String) SDtable.getValueAt(fila, columna);
            
            if(valorActual == null || valorActual.isEmpty()){
                
                JOptionPane.showMessageDialog(this, "Bloque " + numeroCelda + ". Libre");

            }else{
                
                JOptionPane.showMessageDialog(this, "Bloque " + numeroCelda + ". " + valorActual);

            }
            
            
//            if (nuevoValor != null) {
//                SDtable.setValueAt(nuevoValor, fila, columna);
//            }
        }

    }//GEN-LAST:event_SDtableMouseClicked

    
    
    private void llenarTablaArchivos() {
    DefaultTableModel modeloTabla = (DefaultTableModel) SDtable.getModel();

    // Limpia la tabla antes de llenarla
    modeloTabla.setRowCount(0);

    // Asegura que la tabla tenga 8 filas y 8 columnas
    modeloTabla.setRowCount(8);
    modeloTabla.setColumnCount(8);

    for (int i = 0; i < listaArchivos.size(); i++) {
        Archivo archivo = listaArchivos.get(i);
        modeloTabla.setValueAt(archivo.getNombre(), archivo.getPosicioni(), archivo.getPosicionj());
        System.out.println("\n Nombre archivo " + archivo.getNombre());
        
        cambiarColorCelda(archivo.getPosicioni(), archivo.getPosicionj(), obtenerColorPorNombre(archivo.getColor()));

    }
}
    
    
    private Point obtenerCeldaDisponibleMasCercana() {
    DefaultTableModel modeloTabla = (DefaultTableModel) SDtable.getModel();

    // Recorre la tabla buscando una celda vacía
    for (int fila = 0; fila < 8; fila++) {
        for (int columna = 0; columna < 8; columna++) {
            if (modeloTabla.getValueAt(fila, columna) == null || modeloTabla.getValueAt(fila, columna).toString().isEmpty()) {
                return new Point(fila, columna); // Devuelve las coordenadas de la celda vacía
            }
        }
    }

    System.out.println("No hay espacio disponible");
    return null;
    
}
  
    
    private int contarCeldasDisponibles() {
    DefaultTableModel modeloTabla = (DefaultTableModel) SDtable.getModel();
    int contador = 0;
    for (int fila = 0; fila < 8; fila++) {
        for (int columna = 0; columna < 8; columna++) {
            if (modeloTabla.getValueAt(fila, columna) == null || modeloTabla.getValueAt(fila, columna).toString().isEmpty()) {
                contador++;
            }
        }
    }
    return contador;
}
    
    private void jTree1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTree1MouseClicked
        
        if (evt.getClickCount() == 2) { // Verifica si es doble clic
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();
        
        if (nodoSeleccionado != null && nodoSeleccionado.getUserObject() != null && nodoSeleccionado.getChildCount() == 0) {
            Object userObject = nodoSeleccionado.getUserObject();
            if (userObject instanceof Archivo) { // Verifica si el objeto es de tipo Archivo
                Archivo archivo = (Archivo) userObject;
                String contenido = archivo.getContenido(); // Obtiene el contenido del archivo
                String texto = "Contenido del archivo: " + contenido;
                JOptionPane.showMessageDialog(this, texto);
                
                LocalDateTime ahora = LocalDateTime.now();
                DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                String fechaHora = ahora.format(formateador);

                // Crear registro
                String registro = "\n   El usuario " + this.modoSistema + " leyó el archivo " + archivo.getNombre() + " (ID " + archivo.getId() + "), Fecha/Hora: " + fechaHora;
                listaLogOperaciones.add(registro);
                
            } else {
                JOptionPane.showMessageDialog(this, "El nodo no contiene un archivo válido o es una carpeta");
            }
        }
    }
        
    }//GEN-LAST:event_jTree1MouseClicked

    
    private int asignarID(){
        
        int id = 0;
        id = id + idSiguiente;
        return id;
        
    }
    
    
    public int obtenerIdMasGrande() {
    if (this.listaArchivos.size() == 0) {
        
        System.out.println("La lista esta vacia");
        return 0;
    }

    int idMasGrande = this.listaArchivos.get(0).getId(); // Inicializa con el primer ID
    for (int i = 1; i < this.listaArchivos.size(); i++) {
        int idActual = this.listaArchivos.get(i).getId();
        if (idActual > idMasGrande) {
            idMasGrande = idActual;
        }
    }
    return idMasGrande;
}
    
    
    private void btnCrearArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearArchivoActionPerformed
        
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();

        if (nodoSeleccionado == null) {
            JOptionPane.showMessageDialog(this, "Debe seleccionar una carpeta");
            return; // Salir del método si no hay carpeta seleccionada
        }

        if (!(nodoSeleccionado.getUserObject() instanceof Archivo)) {
            String nombre = JOptionPane.showInputDialog("Nombre del archivo:");

            if (nombre != null && !nombre.isEmpty()) {
                String contenido = JOptionPane.showInputDialog("Contenido del archivo:");

                if (contenido != null && !contenido.isEmpty()) {
                    String strLongitud = JOptionPane.showInputDialog("Longitud del archivo (en bloques):");
                    int longitud = Integer.parseInt(strLongitud);

                    if (longitud > 0) {
                        
                        String[] colores = {
                            "negro", "blanco", "rojo", "rojoclaro", "rojooscuro",
                            "verde", "verdeclaro", "verdeoscuro", "azul", "azulclaro", "azuloscuro",
                            "amarillo", "amarilloclaro", "amarillooscuro", "cyan", "cyanclaro", "cyanoscuro",
                            "magenta", "magentaclaro", "magentaoscuro", "grisoscuro", "gris", "grisclaro",
                            "naranja", "naranjaclaro", "naranjaoscuro", "rosa", "rosaoscuro"
                        };

                        JComboBox<String> colorComboBox = new JComboBox<>(colores);

                        int result = JOptionPane.showConfirmDialog(null, colorComboBox, "Color del archivo:", JOptionPane.OK_CANCEL_OPTION);

                        if (result == JOptionPane.OK_OPTION) {
                            
                            String color = (String) colorComboBox.getSelectedItem();

                            // Verificar si hay suficientes espacios disponibles
                            if (contarCeldasDisponibles() < longitud) {
                                JOptionPane.showMessageDialog(this, "No hay suficientes espacios disponibles para el archivo.");
                                return; // Salir del método si no hay suficientes espacios
                            }
                            
                            // Agregar archivos en diferentes posiciones
                            boolean verTree = true; // Esto es un indicador para que solo se agregue al Jtree una vez
                            
                            for (int i = 0; i < longitud; i++) {
                                Point celdaDisponible = obtenerCeldaDisponibleMasCercana();
                                if (celdaDisponible != null) {
                                    Archivo archivo = new Archivo(nombre, asignarID(), longitud, celdaDisponible.x, celdaDisponible.y, contenido, color);
                                    listaArchivos.append(archivo);
                                    llenarTablaArchivos();
                                    actualizarTabla();
                                    
                                    LocalDateTime ahora = LocalDateTime.now();
                                    DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                                    String fechaHora = ahora.format(formateador);

                                    // Crear registro
                                    String registro = "\n   Se creó el archivo " + nombre + " (ID " + asignarID() + "), Fecha/Hora: " + fechaHora;
                                    listaLogOperaciones.add(registro);
                                    
                                    
                                    if(verTree){
                                        DefaultMutableTreeNode nuevoNodo = new DefaultMutableTreeNode(archivo);
                                        if (nodoSeleccionado == null) {
                                            treeDirectorio.insertNodeInto(nuevoNodo, (DefaultMutableTreeNode) treeDirectorio.getRoot(), treeDirectorio.getChildCount(treeDirectorio.getRoot()));
                                        } else {
                                            treeDirectorio.insertNodeInto(nuevoNodo, nodoSeleccionado, treeDirectorio.getChildCount(nodoSeleccionado));
                                        }
                                    }
                                    
                                    verTree = false;
                                    
                                }
                            }
                            this.idSiguiente++;
                  
                            
                        } else {
                            System.out.println("Operación cancelada.");
                        }
                        
                    }
                }
            }
        } else {
            JOptionPane.showMessageDialog(this, "Debe seleccionar una carpeta");
        }
         
    }//GEN-LAST:event_btnCrearArchivoActionPerformed

    private void btnCrearCarpetaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearCarpetaActionPerformed
        
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();
        
        if(nodoSeleccionado == null){
            JOptionPane.showMessageDialog(this, "Debe seleccionar una carpeta");
        }
        
        if(!(nodoSeleccionado.getUserObject() instanceof Archivo)){
        
        String nombre = JOptionPane.showInputDialog("Nombre de la carpeta:");
        if (nombre != null && !nombre.isEmpty()) {
            DefaultMutableTreeNode nuevoNodo = new DefaultMutableTreeNode(nombre);
            
            LocalDateTime ahora = LocalDateTime.now();
            DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            String fechaHora = ahora.format(formateador);

            // Crear registro
            String registro = "\n   Se creó la carpeta " + nombre + ", Fecha/Hora: " + fechaHora;
            listaLogOperaciones.add(registro);
            
            if (nodoSeleccionado == null) {
                // Si no hay nodo seleccionado, agrega a la raíz
                treeDirectorio.insertNodeInto(nuevoNodo, (DefaultMutableTreeNode) treeDirectorio.getRoot(), treeDirectorio.getChildCount(treeDirectorio.getRoot()));
            } else {
                // Si hay nodo seleccionado, agrega como hijo
                treeDirectorio.insertNodeInto(nuevoNodo, nodoSeleccionado, treeDirectorio.getChildCount(nodoSeleccionado));
            }
        }
        
        }else{
            
            JOptionPane.showMessageDialog(this, "Debe seleccionar una carpeta");
        }
        
        
        
    }//GEN-LAST:event_btnCrearCarpetaActionPerformed

    private void btnEliminarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEliminarActionPerformed
        
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();

        if (nodoSeleccionado == null) {
            JOptionPane.showMessageDialog(this, "Debe seleccionar la carpeta a borrar");
            return;
        }

        if (!(nodoSeleccionado.getUserObject() instanceof Archivo)) {
            
            // Lógica para borrar carpetas
            
            int opcion = JOptionPane.showConfirmDialog(this, "¿Está seguro de que desea borrar la carpeta \"" + nodoSeleccionado.getUserObject() + "\" y todo su contenido?", "Confirmar borrado", JOptionPane.YES_NO_OPTION);
            if (opcion == JOptionPane.YES_OPTION) {
                DefaultMutableTreeNode padre = (DefaultMutableTreeNode) nodoSeleccionado.getParent();
                if (padre != null) {
                    // Borrar los archivos asociados a esta carpeta
                    borrarArchivosDeCarpeta(nodoSeleccionado);

                    // Borrar el nodo del árbol
                    treeDirectorio.removeNodeFromParent(nodoSeleccionado);
                    treeDirectorio.reload(padre); // Recarga el nodo padre para actualizar la vista
                    
                    llenarTablaArchivos();
                    actualizarTabla();
                } else {
                    JOptionPane.showMessageDialog(this, "No se puede borrar la raíz del árbol.", "Error", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
        
        else {
            
        // Lógica para borrar archivos
        int opcion = JOptionPane.showConfirmDialog(this, "¿Está seguro de que desea borrar el archivo \"" + nodoSeleccionado.getUserObject() + "\"?", "Confirmar borrado", JOptionPane.YES_NO_OPTION);
            if (opcion == JOptionPane.YES_OPTION) {
                Object userObject = nodoSeleccionado.getUserObject();
                Archivo archivo = (Archivo) userObject;

                borrarArchivo(archivo.getId());

                DefaultMutableTreeNode padre = (DefaultMutableTreeNode) nodoSeleccionado.getParent();
                if (padre != null) {
                    treeDirectorio.removeNodeFromParent(nodoSeleccionado);//Elimina el nodo del Jtree
                    treeDirectorio.reload(padre); //Recarga el padre para actualizar la vista
                }
                
                llenarTablaArchivos();
                actualizarTabla();
            }
        }
        
    }//GEN-LAST:event_btnEliminarActionPerformed

    private void btnModificarNombreActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnModificarNombreActionPerformed
        
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();

        if (nodoSeleccionado == null) {
            JOptionPane.showMessageDialog(this, "Debe seleccionar un archivo o carpeta");
            return;
        }

        if (nodoSeleccionado.getUserObject() instanceof Archivo) {
            Archivo archivo = (Archivo) nodoSeleccionado.getUserObject();

            String contenidoActual = archivo.getNombre();

            String nuevoContenido = JOptionPane.showInputDialog(this, "Nuevo nombre:", contenidoActual);

            if (nuevoContenido != null && !nuevoContenido.isEmpty()) {
            
                Lista<Archivo> listaAuxiliar = filtrarArchivos(archivo.getId());
                
                for (int i = listaAuxiliar.size() - 1; i >= 0; i--) { // Recorre en orden inverso
                    Archivo archivoAuxiliar = listaAuxiliar.get(i);
                    archivoAuxiliar.setNombre(nuevoContenido);
                }
                DefaultTreeModel modelo = (DefaultTreeModel) jTree1.getModel();
                modelo.nodeChanged(nodoSeleccionado); // Notifica al modelo del cambio
                
                System.out.println("El archivo \"" + contenidoActual + "\" (ID: " + archivo.getId() + ") " + "ha sido renombrado a \"" + archivo.getNombre() + "\"" );
                
                llenarTablaArchivos();
                LocalDateTime ahora = LocalDateTime.now();
                DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                String fechaHora = ahora.format(formateador);

                // Crear registro
                String registro = "\n   Se renombró el archivo " + contenidoActual + " (ID " + archivo.getId() +  ") a " + archivo.getNombre() + ", Fecha/Hora: " + fechaHora;
                listaLogOperaciones.add(registro);
                actualizarTabla();
            }
            
        } else {

            String nuevoNombre = JOptionPane.showInputDialog(this, "Nuevo nombre:", "Modificar Nombre", JOptionPane.QUESTION_MESSAGE);

            if (nuevoNombre != null && !nuevoNombre.isEmpty()) {
                Object data = nodoSeleccionado.getUserObject();
                String nombreAnterior = (String) data;
                nodoSeleccionado.setUserObject(nuevoNombre); // Cambia el nombre en el nodo
                DefaultTreeModel modelo = (DefaultTreeModel) jTree1.getModel();
                modelo.nodeChanged(nodoSeleccionado); // Notifica al modelo del cambio
                
                System.out.println("La carpeta " + nombreAnterior + " ha sido renombrada a " + nuevoNombre);
                
                LocalDateTime ahora = LocalDateTime.now();
                DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                String fechaHora = ahora.format(formateador);

                // Crear registro
                String registro = "\n   Se renombró la carpeta " + nombreAnterior + " a " + nuevoNombre + ", Fecha/Hora: " + fechaHora;
                listaLogOperaciones.add(registro);
            }
            
        }
        
        
    }//GEN-LAST:event_btnModificarNombreActionPerformed

    private void btnModificarContenidoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnModificarContenidoActionPerformed
        
        DefaultMutableTreeNode nodoSeleccionado = (DefaultMutableTreeNode) jTree1.getLastSelectedPathComponent();

        if (nodoSeleccionado == null) {
            JOptionPane.showMessageDialog(this, "Debe seleccionar un archivo a modificar");
            return;
        }

        if (nodoSeleccionado.getUserObject() instanceof Archivo) {
            Archivo archivo = (Archivo) nodoSeleccionado.getUserObject();

            String contenidoActual = archivo.getContenido();

            String nuevoContenido = JOptionPane.showInputDialog(this, "Ingrese el nuevo contenido:", contenidoActual);

            if (nuevoContenido != null) {
            
                Lista<Archivo> listaAuxiliar = filtrarArchivos(archivo.getId());
                
                for (int i = listaAuxiliar.size() - 1; i >= 0; i--) { // Recorre en orden inverso
                    Archivo archivoAuxiliar = listaAuxiliar.get(i);
                    archivoAuxiliar.setContenido(nuevoContenido);

                }
                llenarTablaArchivos();
                LocalDateTime ahora = LocalDateTime.now();
                DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                String fechaHora = ahora.format(formateador);

                // Crear registro
                String registro = "\n   Se modificó el archivo " + archivo.getNombre() + " (ID " + archivo.getId() + "), Fecha/Hora: " + fechaHora;
                listaLogOperaciones.add(registro);

                actualizarTabla();
            }
        } else {
            JOptionPane.showMessageDialog(this, "Solo puede modificar el contenido de archivos.", "Advertencia", JOptionPane.WARNING_MESSAGE);
        }
        
        
    }//GEN-LAST:event_btnModificarContenidoActionPerformed

    private void btnModoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnModoActionPerformed
        
        String[] modos = {
            "Administrador", "Usuario"
        };

        JComboBox<String> modoBox = new JComboBox<>(modos);

        int result = JOptionPane.showConfirmDialog(this, modoBox, "Modo", JOptionPane.OK_CANCEL_OPTION);

        if (result == JOptionPane.OK_OPTION) {
            
            String modo = (String) modoBox.getSelectedItem();
            System.out.println(modo);
            
            LocalDateTime ahora = LocalDateTime.now();
            DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            String fechaHora = ahora.format(formateador);

            // Crear registro
            String registro = "\n   Cambio de modo " + modoSistema + " a modo " + modo + ", Fecha/Hora: " + fechaHora;
            listaLogOperaciones.add(registro);
            
            
            if(modo == "Administrador"){
                
                btnCrearArchivo.setVisible(true);
                btnCrearCarpeta.setVisible(true);
                btnEliminar.setVisible(true);
                btnModificarContenido.setVisible(true);
                btnModificarNombre.setVisible(true);
                btnLogBackup.setVisible(true);
                
                this.modoSistema = "Administrador";
                
            }else{
                btnCrearArchivo.setVisible(false);
                btnCrearCarpeta.setVisible(false);
                btnEliminar.setVisible(false);
                btnModificarContenido.setVisible(false);
                btnModificarNombre.setVisible(false);
                btnLogBackup.setVisible(false);
                
                this.modoSistema = "Usuario";
            }

        } else {
            System.out.println("Operacion cancelada.");
        }
        
    }//GEN-LAST:event_btnModoActionPerformed

    private void btnLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLogActionPerformed
        
        StringBuilder sb = new StringBuilder();
        for (String registro : listaLogOperaciones) {
            sb.append(registro).append("\n");
        }

        LogFrame logFrame = new LogFrame(); // Crea una instancia del LogFrame
        logFrame.logTextArea.setText(sb.toString()); // Establece el texto del JTextArea
        logFrame.setVisible(true); // Hace visible el JFrame
        
    }//GEN-LAST:event_btnLogActionPerformed

    private void btnExportarArchivosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportarArchivosActionPerformed
        exportarArchivosJson();
    }//GEN-LAST:event_btnExportarArchivosActionPerformed

    private void btnImportarArchivosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportarArchivosActionPerformed
        importarArchivosJson();
    }//GEN-LAST:event_btnImportarArchivosActionPerformed

    private void btnImportarArbolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImportarArbolActionPerformed
        importarArbolJson();
    }//GEN-LAST:event_btnImportarArbolActionPerformed

    private void btnExportarArbolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExportarArbolActionPerformed
        exportarArbolJson();
    }//GEN-LAST:event_btnExportarArbolActionPerformed

    private void btnLogBackupActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLogBackupActionPerformed
        exportarLogOperaciones();
    }//GEN-LAST:event_btnLogBackupActionPerformed

    
    private void borrarArchivosDeCarpeta(DefaultMutableTreeNode carpetaNodo) {
        

        LocalDateTime ahora = LocalDateTime.now();
        DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String fechaHora = ahora.format(formateador);

        // Crear registro
        String registro = "\n   Se eliminó la carpeta " + carpetaNodo.getUserObject().toString() + ", Fecha/Hora: " + fechaHora;
        listaLogOperaciones.add(registro);
        
        if (carpetaNodo instanceof DefaultMutableTreeNode) {
            Enumeration<TreeNode> hijos = carpetaNodo.children();
            while (hijos.hasMoreElements()) {
                TreeNode hijo = hijos.nextElement();
                if (hijo instanceof DefaultMutableTreeNode) {
                    DefaultMutableTreeNode defaultHijo = (DefaultMutableTreeNode) hijo;
                    Object userObject = defaultHijo.getUserObject();
                    if (userObject instanceof Archivo) {
                        Archivo archivo = (Archivo) userObject;
                        borrarArchivo(archivo.getId());
                    } else {
                        borrarArchivosDeCarpeta(defaultHijo); // Llama recursivamente con DefaultMutableTreeNode
                    }
                }
            }
        } else {
            System.err.println("Error: carpetaNodo no es DefaultMutableTreeNode");
            JOptionPane.showMessageDialog(this, "Error al borrar la carpeta.", "Error", JOptionPane.ERROR_MESSAGE);
        }
}

    public Lista<Archivo> filtrarArchivos(int id_filtro) {
        Lista<Archivo> lista_filtrada = new Lista<>("Filtrada");
        for (int i = 0; i < this.listaArchivos.size(); i++) {
            Archivo archivo = this.listaArchivos.get(i);
            if (archivo.getId() == id_filtro) {
                lista_filtrada.append(archivo);
            }
        }
        return lista_filtrada;
    }

    public void borrarArchivo(int idArchivo) {

    boolean existe = false;

    for (int i = listaArchivos.size() - 1; i >= 0; i--) { // Recorre en orden inverso
        Archivo archivo = listaArchivos.get(i);
        if (archivo.getId() == idArchivo) {
            renderer.eliminarCelda(archivo.getPosicioni(), archivo.getPosicionj());
            listaArchivos.deleteByIndex(i);
            existe = true;
            System.out.println("Archivo " + archivo.getNombre() + "(ID: " + archivo.getId() + ")" + " eliminado");
            
            LocalDateTime ahora = LocalDateTime.now();
            DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            String fechaHora = ahora.format(formateador);

            // Crear registro
            String registro = "\n   Se eliminó el archivo " + archivo.getNombre() + " (ID " + archivo.getId() + "), Fecha/Hora: " + fechaHora;
            listaLogOperaciones.add(registro);
        }
    }

    if (!existe) {
        System.out.println("No existe");
    }
}

    private void exportarArchivosJson() {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();

        // Convertir la lista de archivos a JSON
        String json = gson.toJson(listaArchivos);
        String rutaArchivo = "src/Exportaciones/Lista de Archivos.json";

        try (FileWriter writer = new FileWriter(rutaArchivo)) {
            writer.write(json);
            writer.flush();
            System.out.println("Ruta de exportación: " + rutaArchivo);
            LocalDateTime ahora = LocalDateTime.now();
            DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            String fechaHora = ahora.format(formateador);

            // Crear registro
            String registro = "\n   Se exportó un lote de "+listaArchivos.size()+" archivos, Fecha/Hora: " + fechaHora;
            listaLogOperaciones.add(registro);
//            JOptionPane.showMessageDialog(this,"Archivos exportados exitosamente.");
        } catch (IOException e) {
            System.out.println("Ocurrió un error al exportar el archivo: "+e);
            JOptionPane.showMessageDialog(this, "Hubo un error en la exportación. Intente de nuevo.");
        }
    }
    
    private void importarArchivosJson() {
        Gson gson = new Gson();
        String rutaArchivo = "src/Exportaciones/Lista de Archivos.json";

        try (FileReader reader = new FileReader(rutaArchivo)) {
            java.lang.reflect.Type listaArchivoType = new TypeToken<Lista<Archivo>>() {}.getType();
            Lista<Archivo> archivosImportados = gson.fromJson(reader, listaArchivoType); //Convierte el JSON en Lista
            listaArchivos = archivosImportados;
            System.out.println("Ruta de importación: " + rutaArchivo);
            LocalDateTime ahora = LocalDateTime.now();
            DateTimeFormatter formateador = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            String fechaHora = ahora.format(formateador);

            // Crear registro
            String registro = "\n   Se importó un lote de "+listaArchivos.size()+" archivos, Fecha/Hora: " + fechaHora;
            listaLogOperaciones.add(registro);
//            JOptionPane.showMessageDialog(this,"Archivos impotados exitosamente.");
            llenarTablaArchivos();
            actualizarTabla();
        } catch (IOException e) {
            System.out.println("Error al importar el archivo JSON. No se encontró 'Lista de Archivos.json en "+rutaArchivo);
            JOptionPane.showMessageDialog(this,"Error. Asegúrese de que exista 'Lista de Archivos.json' en la dirección correcta.");
        }
    }
    
    public void actualizarTabla() {
        System.out.println("Longitud de la lista de archivos: "+listaArchivos.size());
        DefaultTableModel model = (DefaultTableModel) tablaAsignacionArchivos.getModel();
        model.setRowCount(0); // Limpiar la tabla existente. Así se evitan duplicados.

        for (int i = 0; i < listaArchivos.size(); i++) {
            Archivo archivo = listaArchivos.get(i);
            
            // Para verificar si el archivo ya está en la tabla de asignación de archivos
            boolean existe = false;
            for (int j = 0; j < model.getRowCount(); j++) {
                String nombreEnTabla = (String) model.getValueAt(j, 1);
                int idEnTabla = (int) model.getValueAt(j, 0);
                if (archivo.getNombre().equals(nombreEnTabla) || archivo.getId() == idEnTabla) {
                    existe = true;
                    break;
                }
            }

            // Si no existe, agrega el archivo a la tabla
            if (!existe) {
                String parOrdenado = "("+archivo.getPosicionj()+","+archivo.getPosicioni()+")";
                model.addRow(new Object[]{archivo.getId(), archivo.getNombre(), archivo.getLongitud(), parOrdenado, archivo.getColor()});
            }
        }
    }
    
    private void exportarLogOperaciones() {
        String carpetaExportaciones = "src/Exportaciones/";
        String prefijoArchivo = "Logs_";
        String extensionArchivo = ".txt";

        int numeroMaximo = 0;

        File carpeta = new File(carpetaExportaciones);
        if (!carpeta.exists()) {
            carpeta.mkdirs(); // Crea la carpeta si no existe
        }

        File[] archivos = carpeta.listFiles();
        if (archivos != null) {
            for (File archivo : archivos) {
                String nombre = archivo.getName();
                if (nombre.startsWith(prefijoArchivo) && nombre.endsWith(extensionArchivo)) {
                    try {
                        String numeroStr = nombre.substring(prefijoArchivo.length(), nombre.length() - extensionArchivo.length());
                        int numero = Integer.parseInt(numeroStr);
                        if (numero > numeroMaximo) {
                            numeroMaximo = numero;
                        }
                    } catch (NumberFormatException e) {
                        // Ignorar archivos que no cumplan con el formato
                    }
                }
            }
        }

        int nuevoNumero = numeroMaximo + 1;
        String nuevoArchivoNombre = prefijoArchivo + nuevoNumero + extensionArchivo;
        String rutaArchivo = carpetaExportaciones + nuevoArchivoNombre;

        StringBuilder sb = new StringBuilder();
        for (String registro : listaLogOperaciones) {
            sb.append(registro).append("\n");
        }

        try (FileWriter writer = new FileWriter(rutaArchivo)) {
            writer.write(sb.toString());
            writer.flush();
            System.out.println("Log exportado correctamente en: " + rutaArchivo);
            JOptionPane.showMessageDialog(this, "Log exportado exitosamente en:\n" + rutaArchivo);
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, "Ocurrió un error al exportar el log.");
        }
    }

    
    // SECCIÓN RESPALDO ÁRBOL
    
    private TreeNodeData convertirNodo(DefaultMutableTreeNode nodo) {
        Object userObject = nodo.getUserObject();

        if (userObject instanceof Archivo) {
            Archivo archivo = (Archivo) userObject;
            return new TreeNodeData(archivo); // Crear nodo serializable para archivo
        } else {
            TreeNodeData nodoData = new TreeNodeData(userObject.toString(), true); // Nodo carpeta

            // Recorrer los hijos del nodo
            Enumeration<TreeNode> hijos = nodo.children();
            while (hijos.hasMoreElements()) {
                DefaultMutableTreeNode hijo = (DefaultMutableTreeNode) hijos.nextElement();
                nodoData.agregarHijo(convertirNodo(hijo)); // Llamada recursiva
            }
            return nodoData;
        }
    }

    
    private void exportarArbolJson() {
        // Exportar visualmente el árbol (estructura del JTree)
        TreeNodeData raizData = convertirNodo((DefaultMutableTreeNode) treeDirectorio.getRoot());
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String json = gson.toJson(raizData);

        String rutaArchivo = "src/Exportaciones/ArbolDirectorio.json";
        try (FileWriter writer = new FileWriter(rutaArchivo)) {
            writer.write(json);
            writer.flush();
            System.out.println("Estructura del árbol exportada correctamente en: " + rutaArchivo);
            JOptionPane.showMessageDialog(this, "Estructura del árbol exportada exitosamente en:\n" + rutaArchivo);
        } catch (IOException e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "Error al exportar la estructura del árbol.");
        }

        // Exportar los datos de los archivos en paralelo
        exportarArchivosJson();
    }


    private DefaultMutableTreeNode reconstruirArbol(TreeNodeData nodoData) {
        DefaultMutableTreeNode nodo;

        if (!nodoData.isEsCarpeta()) {
            // Crear un objeto Archivo con los datos restaurados
            Archivo archivo = new Archivo(
                nodoData.getNombre(),
                asignarID(), // Generar un ID único
                nodoData.getLongitud(),
                nodoData.getPosicioni(),
                nodoData.getPosicionj(),
                nodoData.getContenido(),
                nodoData.getColor()
            );
            nodo = new DefaultMutableTreeNode(archivo);
            listaArchivos.append(archivo); // Sincronizar con listaArchivos
        } else {
            nodo = new DefaultMutableTreeNode(nodoData.getNombre());
        }

        // Recorrer los hijos y reconstruirlos recursivamente
        for (int i = 0; i < nodoData.getHijos().size(); i++) {
            TreeNodeData hijoData = nodoData.getHijos().get(i);
            nodo.add(reconstruirArbol(hijoData)); // Llamada recursiva
        }

        return nodo;
    }

    private void importarArbolJson() {
        String rutaArchivo = "src/Exportaciones/ArbolDirectorio.json";

        try (FileReader reader = new FileReader(rutaArchivo)) {
            Gson gson = new Gson();
            TreeNodeData raizData = gson.fromJson(reader, TreeNodeData.class);

            // Reconstruir árbol
            DefaultMutableTreeNode nuevaRaiz = reconstruirArbol(raizData);
            treeDirectorio.setRoot(nuevaRaiz);
            jTree1.setModel(treeDirectorio); // Actualizar JTree

            System.out.println("Estructura del árbol importada correctamente desde: " + rutaArchivo);
            JOptionPane.showMessageDialog(this, "Estructura del árbol importada exitosamente.");
        } catch (IOException e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "Error al importar la estructura del árbol.");
        }

        importarArchivosJson();
    }

    /**
     * @param args the command line arguments
     */

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable SDtable;
    private javax.swing.JButton btnCrearArchivo;
    private javax.swing.JButton btnCrearCarpeta;
    private javax.swing.JButton btnEliminar;
    private javax.swing.JButton btnExportarArbol;
    private javax.swing.JButton btnExportarArchivos;
    private javax.swing.JButton btnImportarArbol;
    private javax.swing.JButton btnImportarArchivos;
    private javax.swing.JButton btnLog;
    private javax.swing.JButton btnLogBackup;
    private javax.swing.JButton btnModificarContenido;
    private javax.swing.JButton btnModificarNombre;
    private javax.swing.JButton btnModo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTree jTree1;
    private javax.swing.JTable tablaAsignacionArchivos;
    // End of variables declaration//GEN-END:variables
}
